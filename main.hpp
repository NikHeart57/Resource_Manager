/**
 *
 * Сначала теория ООП потому что у меня склероз и лень, отчего я не могу уже 2 года это выучить :(
 *
 * Основные принципы объектно-ориентированного программирования (ООП) — это 
 *	Абстракция
 *	Инкапсуляция 
 *	Наследование
 *	Полиморфизм
 *
 * Эти принципы помогают разработчикам создавать модульные, повторно используемые и легко поддерживаемые компоненты ПО, 
 * скрывая ненужные детали, объединяя данные с методами, позволяя создавать новые классы на основе существующих и обрабатывать объекты по-разному.
 *
 *	Абстракция
 *		Суть:		Выделение основных, важных для задачи характеристик объекта и сокрытие второстепенных деталей.
 *		Пример:		При использовании лампочки мы не знаем её внутреннее устройство, а только знаем, что её можно включить или выключить.
 *
 *	Инкапсуляция
 *		Суть:		Объединение данных (атрибутов) и методов (функций) объекта в единое целое, а также сокрытие внутренней реализации объекта от внешнего мира.
 *		Пример:		У объекта "Машина" есть свойства (скорость, цвет) и методы (поехать). Внешний мир видит, как машина едет, но не видит сложную механику.
 *
 *	Наследование
 *		Суть:		Создание новых классов (объектов-потомков) на основе существующих (объектов-родителей), перенимая их свойства и методы.
 *		Пример:		От класса "Животное" можно создать класс "Собака", добавив новый метод "лаять".
 *
 * Полиморфизм
 *		Суть:		Способность объектов разных классов выполнять один и тот же метод по-разному.
 *		Пример:		Команда "прыгать" будет реализована по-разному для объектов "Кошка" и "Лягушка".
 *
 *
 *
 *
 *
 * Теперь по проекту:
 * Паттерн "Владелец-Ресурс" (Owner-Resource Pattern) или "Менеджер ресурсов".
 *
 * 1. Драйвер (Driver) — КАК сделать? (Слой реализации)
 *	Назначение: 
 *		Низкоуровневая работа непосредственно с железом микроконтроллера. Переводящая язык регистров на язык функций.
 *	Уровень: 
 *		Аппаратный (Hardware), максимально близко к "металлу".
 *  Знает:
 *		Адреса регистров (SFR), битовые маски.
 *		Процедуры инициализации, тайминги.
 *		Обработчики прерываний (ISR).
 *  Не знает:
 *		Бизнес-логику приложения.
 *		Существование других драйверов или ресурсов.
 *		Состояние системы.
 *  Ответственность:
 *		Прямое управление периферией через запись/чтение регистров.
 *		Предоставление чистого, минималистичного API для управления конкретным блоком (например, UART_SendByte(), GPIO_SetPin()).
 *  Аналог: Водитель такси, который идеально знает устройство своей машины и как ей управлять, но не знает, куда и зачем едет пассажир.
 * 
 *
 * 2. Ресурс (Resource) — ЧЕМ сделать? (Слой абстракции)
 *	Назначение: 
 *		Высокоуровневая абстракция аппаратного или логического компонента системы. Инкапсуляция драйвера и предоставление удобного, 
 *		безопасного API в соответствии с принципами ООП.
 *	Уровень: 
 * 		Абстракционный (Middleware).
 *	Знает:
 *		Интерфейс своего драйвера (использует его, но не знает его реализации).
 *		Свое внутреннее состояние (включен/выключен, настроен, данные в буфере).
 *		Свой жизненный цикл (RAII: конструктор/деструктор).
 *	Не знает:
 *		Как именно работает железо "под капотом" (это знает драйвер).
 *		Кто и как его использует (это знает ядро).
 *	Ответственность:
 *		Управление жизненным циклом компонента: инициализация, конфигурация, безопасное выключение.
 *		Предоставление идиоматичного C++ интерфейса (напр., uart.write("Hello"), timer.start()).
 *		Обработка ошибок и управление состоянием на своем уровне.
 * Аналог: 
 *		Такси-сервис (например, Uber). У него есть водители (драйверы) и машины (железо). 
 *		Он предоставляет вам простой интерфейс (приложение) для вызова машины, скрывая от вас все детали: 
 *		какого конкретно водителя он найдет, на какой именно машине он приедет.
 * 
 *
 * 3. Ядро (Kernel) / Владелец (Owner) — КТО и КОГДА использует? (Слой координации)
 *	Назначение: 
 *		Высший орган управления, который владеет всеми ресурсами и координирует их работу для выполнения задач приложения. Это "мозг" системы.
 *	Уровень: 
 *		Прикладной (Application), системная архитектура.
 *	Знает:
 *		ВСЕ ресурсы, которые есть в системе (композиция).
 *		Состояние всей системы в целом.
 *		Бизнес-логику приложения или алгоритмы планирования.
 *	Не знает:
 *		Как работают драйверы (он работает только с интерфейсами ресурсов).
 *		Детали реализации железа.
 *	Ответственность:
 *		Владение (Ownership): Создание и время жизни всех ключевых ресурсов.
 *		Координация: Связывание ресурсов между собой. Например, "по получению данных по UART (UART_Resource), записать их в файл на SD-карту (SD_Resource)".
 *		Предоставление доступа: Разрешение другим, менее значимым модулям, заимствовать ресурсы (через методы типа getUART()) для выполнения конкретных задач.
 *		Обеспечение целостности системы: Контроль за тем, чтобы конфликтующие ресурсы не использовались одновременно.
 *	Аналог: 
 *		Вы, как руководитель. У вас есть отдел продаж (UART), логистики (SPI), склад (память). 
 *		Вы не разгружаете фуры сами (работа драйвера) и не звоните клиентам (работа ресурса). 
 *		Вы ставите задачу отделу продаж "продать 100 единиц товара", а отделу логистики — "доставить их со склада к клиенту", координируя их работу между собой.
 *
 * 4. Приложение (Application) — ЗАЧЕМ? (Слой бизнес-логики)
 *	Назначение:
 *		Реализация конечной цели устройства — его бизнес-логики и полезной функциональности. Определяет поведение системы в ответ на внешние события и внутренние состояния.
 *	Уровень:
 *		Прикладной (Application), высокоуровневая логика.
 *	Знает:
 *		Зачем нужны ресурсы. Понимает сценарии использования: "если получена команда 'включи' по UART, то установить вывод GPIO в HIGH".
 *		Конечные автоматы (state machines) поведения устройства.
 *		Протоколы прикладного уровня, алгоритмы обработки данных.
 *		Состояние выполняемой задачи (например, прогресс передачи файла).
 *	Не знает:
 *		Как реализованы ресурсы и драйверы. Для него UART — это просто объект с методом println(), а не набор регистров USART.
 *		Как ядро управляет доступом к ресурсам. Оно просто запрашивает их и использует.
 *	Ответственность:
 *		Реализация алгоритмов и сценариев работы конечного устройства.
 *		Реагирование на ввод пользователя, данные от датчиков, сообщения из сети.
 *		Оркестровка работы ресурсов для достижения комплексных задач (например, "опросить температуру -> отправить на сервер -> уснуть на 1 минуту").
 *		Обеспечение реакции системы в реальном времени на основе её текущего состояния.
 *	Аналог:
 *		Бизнес-логика компании (например, "Служба доставки пиццы"). Службе не важно, какие именно машины в автопарке (Ресурсы) и как они технически устроены (Драйверы). Её задача — используя предоставленный транспорта (через Ядро-логиста), выполнить главную цель: взять горячую пиццу и быстро доставить её клиенту. Она определяет что делать, в какой последовательности и зачем.
 *
 *
 * Еще раз коротко:
 *	Драйверы (GPIO, UART): Чистый, низкоуровневый, процедурный C-код. Знает ТОЛЬКО о регистрах микроконтроллера.
 *		Это слой "КАК?".
 *  Ресурсы (UART_Resource): Классы C++, которые инкапсулируют драйверы. Предоставляют удобный, безопасный и объектно-ориентированный API.
 *		Это слой "ЧЕМ?".
 *  Ядро системы (SystemKernel): Выступает в роли "Владельца" (Owner) или "Менеджера". Он создает и напрямую владеет всеми ресурсами, координирует их работу.
 *		Это слой "КТО ИМЕЕТ ДОСТУП?".
 *	Приложение (Application): Содержит бизнес-логику, сценарии использования и алгоритмы работы конечного устройства. Использует ресурсы, предоставленные ядром, для выполнения полезной работы.
 *		Это слой "ЗАЧЕМ?"
 *
 *
 *	Схема архитектуры:
 *
 *		[ Application ] 									(ЗАЧЕМ? Бизнес-логика. Знает сценарии использования)
 *				|                                     
 *				| Заимствует у ядра ресурс 
 *              | (НЕКОТОРЫЙ РЕСУРС, НЕ ВСЕ)            
 *				V                                     
 *		[ System Kernel ] 									(КТО? Координатор/Владелец. Знает все ресурсы)
 *				|                                     
 *				| Владеет русурсами 
 *              |     (ВСЕМИ)                            
 *				V                                     
 *		[ UART_Resource ]   [ SPI_Resource ]				(ЧЕМ? Абстракция. Знает интерфейс драйвера)
 *				|                   |                 
 *				| Использует        | Использует    
 *				| железку			| железку	
 *				| МК				| МК	
 *				V                   V                 
 *		[ UART Driver ]     [ SPI Driver ]					(КАК? Реализация. Знает регистры, прерывания)
 *				|                   |                 
 *				| Дергает			| Дергает 
 *				| регистры			| регистры 
 *				| железки			| железки
 *				V                   V                 
 *		[ UART Hardware ]   [ SPI Hardware ]				(Железо микроконтроллера)
 *
 *
 * Краткое резюме по схеме:
 *
 *	Application (Приложение)
 *		Спросит у ядра: "Дай мне UART, мне нужно отправить данные."
 *		Получит от ядра: systemKernel.getUART().
 *		Сделает: uart.println("Hello");
 *  System Kernel (Ядро)
 *		Знает: У него есть uart_ и spi_.
 *		Сделает: "Вот тебе ссылка на мой ресурс uart_, используй его."
 *		UART_Resource (Ресурс)
 *		Знает: У него есть драйвер UART_SendByte().
 *		Сделает: "Драйвер, отправь эти символы!" -> UART_SendBuffer(data, length);
 *  UART Driver (Драйвер)
 *		Знает: Адрес регистра UDR и бит UDRE.
 *		Сделает: while(!(UCSRA & (1<<UDRE))); UDR = data;
 *  UART Hardware (Железо)
 *		Сделает: "О, в моём регистре UDR данные! Надо отправить их по проводу."
 *
 *
 *
 *
 *
 * Про ядро и про приложение
 *
 * Конкретные обязанности Ядра (SystemKernel)
 *	Владение и время жизни (Ownership):
 *		Создает ресурсы в своем конструкторе.
 *		Гарантирует, что они будут корректно уничтожены (через свои деструкторы).
 *	Инициализация и конфигурация:
 *		Метод initialize() настраивает ресурсы в нужном порядке и с правильными параметрами.
 *		Пример: Ядро знает, что перед использованием SPI нужно сконфигурировать пины GPIO. Оно вызывает SPI_Resource.start(), который внутри себя дергает GPIO_SetDirection() для пинов MOSI, MISO, SCK.
 *	Предоставление контролируемого доступа:
 *		Через методы типа getUART() ядро не отдает ресурс, а дает его во временное пользование (заимствование, borrowing).
 *		Это позволяет в будущем легко добавить:
 *		Логирование доступа к ресурсу.
 *		Проверку прав (например, запретить доступ к I2C из прерывания высокого приоритета, если он уже занят).
 *		Статистику использования.
 *		Безопасное ожидание освобождения ресурса (мьютексы, критически секции).
 *	Координация конфликтующих ресурсов:
 *		Ядро — единственное место, которое знает обо всех ресурсах сразу.
 *		Пример: Вы не можете использовать ADC и одновременно использовать ногу PC0 как простой вход. Ядро может предоставлять API для атомарной смены режима всей периферии
 *
 * Конкретные обязанности Приложения (Application)
 *	Бизнес-логика:
 *		Диктует последовательность действий для достижения цели.
 *		Пример: "Прочитать данные с датчика (I2C) -> обработать их -> отправить результат по UART -> если результат критический, мигнуть светодиодом (GPIO)".
 *	Сценарии использования:
 *		Реагирует на внешние события (нажатие кнопки, получение команды).
 *		Управляет конечными автоматами (state machines) поведения устройства.
 *	Работа с данными:
 *		Парсинг команд, формирование пакетов, работа с протоколами прикладного уровня.
 *
 * 
 *  Как выглядит поток управления?
 *
 *	[main.cpp]
 *		|
 *		| Создает
 *		V
 *	[SystemKernel] <--- (владеет) --- [UART_Resource]
 *		|                             [SPI_Resource]
 *		| Вызывает initialize()             ...
 *		| (настраивает ресурсы)
 *		|		
 *		| Создает, передает ссылку на себя
 *		V
 *	[Application] -------------------> (использует/заимствует)
 *		|                              system.getUART().println(...)
 *		| Вызывает run()               system.getSPI().transfer(...)
 *		| (реализует логику)
 *		V
 *	[Бесконечный цикл]
 *
 */
#pragma once

// Проверка поддержки C++11:
#if __cplusplus < 201103L
#error "C++11 support required! Add -std=c++11 to compiler flags"
#endif

// Проверка F_CPU
#ifndef F_CPU
#error "F_CPU must be defined in project settings! Add F_CPU=16000000UL"
#endif

#include <avr/io.h>

#include "core/SystemKernel.hpp"
#include "application/Application.hpp"

