/**
 *
 * Сначала теория ООП потому что у меня склероз и лень, отчего я не могу уже 2 года это выучить :(
 *
 * Основные принципы объектно-ориентированного программирования (ООП) — это 
 *	Абстракция
 *	Инкапсуляция 
 *	Наследование
 *	Полиморфизм
 *
 * Эти принципы помогают разработчикам создавать модульные, повторно используемые и легко поддерживаемые компоненты ПО, 
 * скрывая ненужные детали, объединяя данные с методами, позволяя создавать новые классы на основе существующих и обрабатывать объекты по-разному.
 *
 *	Абстракция
 *		Суть:		Выделение основных, важных для задачи характеристик объекта и сокрытие второстепенных деталей.
 *		Пример:		При использовании лампочки мы не знаем её внутреннее устройство, а только знаем, что её можно включить или выключить.
 *
 *	Инкапсуляция
 *		Суть:		Объединение данных (атрибутов) и методов (функций) объекта в единое целое, а также сокрытие внутренней реализации объекта от внешнего мира.
 *		Пример:		У объекта "Машина" есть свойства (скорость, цвет) и методы (поехать). Внешний мир видит, как машина едет, но не видит сложную механику.
 *
 *	Наследование
 *		Суть:		Создание новых классов (объектов-потомков) на основе существующих (объектов-родителей), перенимая их свойства и методы.
 *		Пример:		От класса "Животное" можно создать класс "Собака", добавив новый метод "лаять".
 *
 * Полиморфизм
 *		Суть:		Способность объектов разных классов выполнять один и тот же метод по-разному.
 *		Пример:		Команда "прыгать" будет реализована по-разному для объектов "Кошка" и "Лягушка".
 *
 *
 *
 *
 *
 * Теперь по проекту:
 * Эволюция архитектуры: от "Владелец-Ресурс" к "Микроядру RTOS".
 *
 * Изначальный паттерн "Владелец-Ресурс" (Owner-Resource Pattern) был хорошим началом.
 * С добавлением планировщика задач система эволюционировала в нечто большее — простую, но полноценную RTOS (Real-Time Operating System).
 * Ядро (SystemKernel) теперь является не просто менеджером, а **микроядром**.
 *
 * 1. Драйвер (Driver) — КАК сделать? (Слой реализации)
 *	Назначение: 
 *		Низкоуровневая работа непосредственно с железом микроконтроллера. Переводящая язык регистров на язык функций.
 *	Уровень: 
 *		Аппаратный (Hardware), максимально близко к "металлу".
 *  Знает:
 *		Адреса регистров (SFR), битовые маски.
 *		Процедуры инициализации, тайминги.
 *		Обработчики прерываний (ISR).
 *  Не знает:
 *		Бизнес-логику приложения.
 *		Существование других драйверов или ресурсов.
 *		Состояние системы.
 *  Ответственность:
 *		Прямое управление периферией через запись/чтение регистров.
 *		Предоставление чистого, минималистичного API для управления конкретным блоком (например, UART_SendByte(), GPIO_SetPin()).
 *  Аналог: Водитель такси, который идеально знает устройство своей машины и как ей управлять, но не знает, куда и зачем едет пассажир.
 * 
 *
 * 2. Ресурс (Resource) — ЧЕМ сделать? (Слой абстракции)
 *	Назначение: 
 *		Высокоуровневая абстракция аппаратного или логического компонента системы. Инкапсуляция драйвера и предоставление удобного, 
 *		безопасного API в соответствии с принципами ООП.
 *	Уровень: 
 * 		Абстракционный (Middleware).
 *	Знает:
 *		Интерфейс своего драйвера (использует его, но не знает его реализации).
 *		Свое внутреннее состояние (включен/выключен, настроен, данные в буфере).
 *		Свой жизненный цикл (RAII: конструктор/деструктор).
 *	Не знает:
 *		Как именно работает железо "под капотом" (это знает драйвер).
 *		Кто и как его использует (это знает ядро).
 *	Ответственность:
 *		Управление жизненным циклом компонента: инициализация, конфигурация, безопасное выключение.
 *		Предоставление идиоматичного C++ интерфейса (напр., uart.write("Hello"), timer.start()).
 *		Обработка ошибок и управление состоянием на своем уровне.
 * Аналог: 
 *		Такси-сервис (например, Uber). У него есть водители (драйверы) и машины (железо). 
 *		Он предоставляет вам простой интерфейс (приложение) для вызова машины, скрывая от вас все детали: 
 *		какого конкретно водителя он найдет, на какой именно машине он приедет.
 * 
 *
 * 3. Ядро ОС (OS Kernel) / Владелец (Owner) — КТО, КОГДА и В КАКОЙ ПОСЛЕДОВАТЕЛЬНОСТИ использует? (Слой координации + Управление выполнением)
 *  Назначение:
 *       Высший орган управления, который не только владеет всеми ресурсами, но и управляет временем выполнения задач.
 *       Это "мозг" и "сердце" системы, дирижер оркестра.
 *  Уровень:
 *       Системный (System), уровень операционной системы.
 *  НОВЫЕ ОБЯЗАННОСТИ (помимо старых):
 *       Владение задачами (Task Ownership): Создание, управление жизненным циклом и уничтожение задач.
 *       Планирование (Scheduling): Решение, КАКАЯ задача должна выполняться в данный момент времени, на основе приоритетов и состояний (READY, SLEEPING, SUSPENDED).
 *       Синхронизация (Synchronization): Предоставление механизмов для?? взаимодействия задач (например, сон на определенное время `sleep()`).
 *       Управление временем (Time Management): Подсчет системных тиков, которые являются "пульсом" всей ОС.
 *  Знает:
 *       ВСЕ ресурсы и ВСЕ задачи в системе.
 *       Состояние всей системы и расписание выполнения.
 *	Не знает:
 *		Как работают драйверы (он работает только с интерфейсами ресурсов).
 *		Детали реализации железа.
 *	Ответственность:
 *		Владение (Ownership): Создание и время жизни всех ключевых ресурсов.
 *		Координация: Связывание ресурсов между собой. Например, "по получению данных по UART (UART_Resource), записать их в файл на SD-карту (SD_Resource)".
 *		Предоставление доступа: Разрешение другим, менее значимым модулям, заимствовать ресурсы (через методы типа getUART()) для выполнения конкретных задач.
 *		Обеспечение целостности системы: Контроль за тем, чтобы конфликтующие ресурсы не использовались одновременно.
 *       + Диспетчеризация задач (вызов функции `dispatch()` в бесконечном цикле).
 *       + Обработка прерывания системного таймера и обновление состояний задач (`tick()`).
 *   Аналог:
 *       Диспетчерская служба такси + аэропорт с диспетчерской вышкой.
 *       Вы не только раздаете машины (ресурсы), но и принимаете заказы (задачи) от клиентов,
 *       составляете оптимальный график движения всех машин, следите за их местоположением и состоянием (свободна/занята/на заправке),
 *       и даете команды, кому куда ехать следующему.
 *
 * 4. Приложение (Application) — ЗАЧЕМ? (Слой бизнес-логики, разбитый на задачи)
 *   Назначение:
 *       Реализация конечной цели устройства, представленная в виде набора независимых или слабосвязанных задач (функций).
 *       Каждая задача инкапсулирует свой собственный, часто бесконечный, алгоритм.
 *   Уровень:
 *       Прикладной (Application), но теперь структурированный.
 *   НОВАЯ СТРУКТУРА:
 *       Приложение больше не является монолитом с одним методом `run()`.
 *       Оно регистрирует в ядре одну или несколько функций-задач с указанием их приоритета.
 *       Логика приложения распределена между этими задачами.
 *	Знает:
 *		Зачем нужны ресурсы. Понимает сценарии использования: "если получена команда 'включи' по UART, то установить вывод GPIO в HIGH".
 *		Конечные автоматы (state machines) поведения устройства.
 *		Протоколы прикладного уровня, алгоритмы обработки данных.
 *		Состояние выполняемой задачи (например, прогресс передачи файла).
 *		+ Как разбить глобальную бизнес-логику на отдельные потоки выполнения (задачи).
 *	Не знает:
 *		Как реализованы ресурсы и драйверы. Для него UART — это просто объект с методом println(), а не набор регистров USART.
 *		Как ядро управляет доступом к ресурсам. Оно просто запрашивает их и использует.
 *       + Когда и как часто она будет выполняться. Это решает ядро-планировщик.
 *       + Каждая задача должна быть написана так, чтобы не блокировать надолго выполнение (быть "дружелюбной" к кооперативному планировщику).
 *       + Задача должна либо завершаться за разумное время, либо явно возвращать управление ядру (через `sleep()` или другие будущие механизмы).
 *   Аналог:
 *       Теперь это не просто "Служба доставки пиццы", а "Центр управления полетами".
 *       Одна задача (диспетчер) следит за поступлением новых заказов (UART).
 *       Вторая задача (логист) планирует маршруты для курьеров.
 *       Третья задача (отчетность) раз в час отправляет статистику на сервер.
 *       Все они работают параллельно (квази-параллельно), независимо друг от друга, под управлением ядра-диспетчера.
 *
 *
 *   Драйверы (GPIO, UART): Чистый, низкоуровневый, процедурный C-код. Знает ТОЛЬКО о регистрах микроконтроллера.
 *       Это слой "КАК?".
 *   Ресурсы (UART_Resource): Классы C++, которые инкапсулируют драйверы. Предоставляют удобный, безопасный и объектно-ориентированный API.
 *       Это слой "ЧЕМ?".
 *   Ядро ОС (SystemKernel): Выступает в роли "Микроядра". Оно владеет всеми ресурсами и всеми задачами. Управляет доступом к ресурсам и планирует выполнение задач.
 *       Это слой "КТО? КОГДА? И В КАКОМ ПОРЯДКЕ?".
 *   Приложение (Application): Набор задач, реализующих бизнес-логику. Использует ресурсы, предоставленные ядром, для выполнения полезной работы.
 *       Это слой "ЗАЧЕМ?", разбитый на модули ("зачем-1", "зачем-2", ...).
 *
 *
 *   Схема архитектуры (Обновленная):
 *
 *                                               |-> [ Task 1 ] (ЗАЧЕМ-1?)
 *                                               |-> [ Task 2 ] (ЗАЧЕМ-2?)
 *       [ Application ] (Регистрирует задачи) ->|-> [ Task 3 ] (ЗАЧЕМ-3?)
 *                       |                       |-> [ ... ]
 *                       | Регистрирует задачи   |
 *                       V                       | Выполняет
 *       [ System Kernel ] (Микроядро) <----------------------------|
 *           |            |                                         ^
 *           |            | Планирует, диспетчеризирует             |
 *           |            | (КТО? КОГДА?)                           |
 *           |            |                                         |
 *           |            V                                         |
 *           |    [ Scheduler ] (Компонент ядра)                    |
 *           |            |                                         |
 *           |            | Управляет временем (tick!)              |
 *           |            V                                         |
 *           |    [ System Timer ] (Аппаратное прерывание) ---------|
 *           |
 *           | Владеет, предоставляет доступ
 *           V
 *       [ UART_Resource ]   [ SPI_Resource ]  (ЧЕМ? Абстракция)
 *               |                   |
 *               | Использует        | Использует
 *               V                   V
 *       [ UART Driver ]     [ SPI Driver ]    (КАК? Реализация)
 *               |                   |
 *               | Дергает           | Дергает
 *               V                   V
 *       [ UART Hardware ]   [ SPI Hardware ]  (Железо)
 *
 *
 * Краткое резюме по схеме:
 *
 *  Application (Приложение)
 *       Говорит ядру: "Вот тебе три задачи, которые нужно выполнять: heartbeat, чтение датчика, опрос кнопки. Вот их приоритеты."
 *  System Kernel (Ядро ОС)
 *       Знает: У него есть задачи T1, T2, T3 и ресурсы UART, SPI.
 *       Делает: "Так, задача чтения датчика (T2) с высоким приоритетом проснулась -> выполняю её. Она запросила UART -> даю ей ресурс."
 *       Делает: "T2 завершила работу с UART и уснула на 500 мс -> возвращаю ресурс UART. Теперь самая старшая готовая задача - T1 -> выполняю её."
 *  Scheduler (Планировщик)
 *       Вызывается из бесконечного цикла ядра `dispatch()`. Постоянно сканирует список задач, выбирает лучшую кандидатуру на выполнение.
 *       Вызывается из прерывания таймера `tick()`. Уменьшает счетчики сна для всех спящих задач.
 *	UART_Resource (Ресурс)
 *		Знает: У него есть драйвер UART_SendByte().
 *		Сделает: "Драйвер, отправь эти символы!" -> UART_SendBuffer(data, length);
 *  UART Driver (Драйвер)
 *		Знает: Адрес регистра UDR и бит UDRE.
 *		Сделает: while(!(UCSRA & (1<<UDRE))); UDR = data;
 *  UART Hardware (Железо)
 *		Сделает: "О, в моём регистре UDR данные! Надо отправить их по проводу."
 *
 *
 *
 *
 *
 * Про ядро и про приложение
 *
 * Конкретные обязанности Ядра ОС (SystemKernel)
 *	Владение аппаратными ресурсами (Hardware Resource Ownership):
 *		Создает и владеет всеми ресурсами (UART, SPI и т.д.) в своем конструкторе.
 *		Гарантирует их корректную инициализацию и освобождение.
 *	Владение задачами (Task Ownership):
 *		Предоставляет API (например, `addTask()`) для регистрации задач в системе.
 *		Хранит и управляет списком всех задач, их состояниями и приоритетами.
 *	Планирование выполнения (Scheduling):
 *		Реализует алгоритм планировщика (в методе `dispatch()`), который постоянно выбирает следующую задачу для выполнения на основе приоритета и состояния (READY, SLEEPING, SUSPENDED).
 *		Обеспечивает квази-параллельное выполнение множества задач.
 *	Управление временем (Time Management):
 *		Предоставляет источник системного времени через системный таймер и счетчик тиков.
 *		Обновляет состояния задач (например, уменьшает счетчики сна) в прерывании таймера (метод `tick()`).
 *		Предоставляет функциям задач API для работы со временем (например, `sleep()`).
 *	Предоставление контролируемого доступа к ресурсам:
 *		Через методы типа `getUART()` ядро предоставляет доступ к ресурсам в рамках модели заимствования (borrowing).
 *		**КРАЙНЕ ВАЖНО:** Эта модель теперь должна быть **безопасной для многозадачной среды**. Это задел на будущее для реализации мьютексов (mutexes) или подобных механизмов, которые будут предотвращать одновременный доступ к ресурсу из разных задач.
 *	Координация конфликтующих ресурсов:
 *		Ядро — единственное место, которое знает обо всех ресурсах и задачах сразу.
 *		Пример: Задача с низким приоритетом заняла ресурс ADC. Задача с высоким приоритетом запрашивает ADC. Ядро может принять решение о приоритетном доступе или организовать очередь.
 *
 * Конкретные обязанности Приложения (Application)
 *	Декомпозиция на задачи (Decomposition into Tasks):
 *		Главная новая ответственность — грамотно разбить всю бизнес-логику на отдельные, по возможности независимые, задачи-функции.
 *		Пример: Вместо одного монолитного цикла `run()`, создать: `task_Heartbeat()`, `task_ReadSensor()`, `task_HandleUI()`.
 *	Бизнес-логика внутри задач:
 *		Каждая задача инкапсулирует свою часть общей логики.
 *		Пример: Задача `task_ReadSensor()`: "Раз в 100 мс прочитать данные с датчика (I2C) -> обработать их -> отправить результат в очередь для других задач".
 *	Сценарии использования:
 *		Реагирование на внешние события теперь часто происходит внутри отдельных задач, "заточенных" под это событие (например, задача обработки кнопки).
 *	Управление конечными автоматами (State Machines):
 *		Конечные автоматы поведения теперь могут быть распределены по нескольким задачам или реализованы внутри одной выделенной задачи-диспетчера.
 *	Кооперативность (Cooperativeness):
 *		Задачи должны быть написаны таким образом, чтобы не блокировать выполнение надолго. Они должны либо быстро завершать свою работу, либо явно отдавать управление планировщику (через `sleep()` или другие будущие механизмы вроде `yield()` или ожидания событий).
 *
 *
 *  Как выглядит поток управления? (ОБНОВЛЕННАЯ СХЕМА)
 *
 *	[main.cpp]
 *		|
 *		| Создает ядро, вызывает его инициализацию
 *		V
 *	[SystemKernel] <--- (владеет) --- [UART_Resource] [SPI_Resource] ...
 *		| ^  | ^
 *		| |  | | (Владеет и управляет)
 *		| |  | |
 *		| |  | | (Регистрирует)
 *		| |  | V
 *		| |  [Scheduler] <--- [Task 1] [Task 2] [Task 3] ... (Список задач)
 *		| |    |  |            |        |        |
 *		| |    |  |            |        |        |
 *		| |    |  | (Диспетчеризация)   |        |
 *		| |    |  |----------------------        |
 *		| |    | (Управление временем)           |
 *		| |    |---------------------------------
 *		| | (Вызов из прерывания таймера)
 *		| |--------------------------------------
 *		|
 *		| (Бесконечный цикл ядра)
 *		|-----> while(true) { scheduler.dispatch(); }
 *		|
 *		| (Приложение инициализировано, задачи зарегистрированы)
 *		V
 *	[Бесконечный цикл планировщика]
 *		|
 *		|--> [Выполняется Task 2] -> sleep(500) -> [Возврат в планировщик]
 *		|--> [Выполняется Task 1] -> ...          -> [Возврат в планировщик]
 *		|--> [Выполняется Task 3] -> ...          -> [Возврат в планировщик]
 *		|--> [Планировщик решает, что все задачи спят или suspended -> может выполнить idle task]
 *		V
 *	[... и так по кругу ...]
 *
 */
#pragma once

// Проверка поддержки C++11:
#if __cplusplus < 201103L
#error "C++11 support required! Add -std=c++11 to compiler flags"
#endif

// Проверка F_CPU
#ifndef F_CPU
#error "F_CPU must be defined in project settings! Add F_CPU=16000000UL"
#endif

#include <avr/io.h>

#include "core/SystemKernel.hpp"
#include "application/Application.hpp"

